<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<meta name="generator" content="Doxygen 1.10.0"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>Nebula: Core</title>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
			<table cellspacing="0" cellpadding="0">
				<tbody>
					<tr style="height: 56px;">
						<td id="projectalign" style="padding-left: 0.5em;">
							<div id="projectname">Nebula
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part --><!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('_core.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Core</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="NebulaCoreSystem"></a>
The Core Subsystem</h1>
<p>The <a class="el" href="namespace_nebula.html">Nebula</a> <a class="el" href="namespace_core.html">Core</a> subsystem (as the name implies) implements the core concepts of <a class="el" href="namespace_nebula.html">Nebula</a> which are:</p>
<ul>
<li>a RefCounted base class which implements a strong ref counting mechanism</li>
<li>a runtime type information system</li>
<li>a templated smart pointer class Ptr&lt;&gt; which manages the life time of RefCounted objects</li>
<li>a factory mechanism which allows to construct C++ objects from their string class name</li>
<li>a central Server object which setup the basic <a class="el" href="namespace_nebula.html">Nebula</a> runtime environment</li>
</ul>
<h2><a class="anchor" id="NebulaObjectModel"></a>
The Object Model</h2>
<p><a class="el" href="namespace_nebula.html">Nebula</a> implements a basic object model which implements the following features on top of the C++ object model:</p>
<ul>
<li>lifetime management by refcounting and smart pointers</li>
<li>object creation by string or fourcc class identifier</li>
<li>a runtime type information system</li>
</ul>
<h2><a class="anchor" id="NebulaClassImplementation"></a>
Implementing A New Nebula Class</h2>
<p>The first decision when implementing a new class should be whether the new class should be derived from the <a class="el" href="class_core_1_1_ref_counted.html" title="The common base class of Nebula.">Core::RefCounted</a> class or whether it should be a traditional C++ class. The following points should help to find the answer:</p>
<ul>
<li>if the class wants to make use of the extended <a class="el" href="namespace_nebula.html">Nebula</a> object model features like refcounting, RTTI, and so forth, it must be derived from the <a class="el" href="class_core_1_1_ref_counted.html" title="The common base class of Nebula.">Core::RefCounted</a> class</li>
<li>if the class is a typical small helper or utility class, like a dynamic array class, a math vector class, or something similar, it often does not make sense to derive from <a class="el" href="class_core_1_1_ref_counted.html" title="The common base class of Nebula.">Core::RefCounted</a>.</li>
<li>if the class should mainly be used to store state or data, use a struct instead.</li>
</ul>
<p>Deriving from the <a class="el" href="class_core_1_1_ref_counted.html" title="The common base class of Nebula.">Core::RefCounted</a> class implies some restrictions:</p>
<ul>
<li>RefCounted-derived objects may never be created directly in the local C++ context as stack objects, since stack objects are lifetime- managed by C++ (they are destroyed when the current C++ context is left, circumventing <a class="el" href="namespace_nebula.html">Nebula</a>'s refcounted lifetime management completely)</li>
<li>RefCounted-derived classes only have a default constructor.</li>
<li>RefCounted-derived classes must have a virtual destructor.</li>
<li>RefCounted-derived classes must not be copied, since this would confuse the refcounting mechanism.</li>
</ul>
<p>To make use of the <a class="el" href="namespace_nebula.html">Nebula</a> object model features, one needs to derive from the <a class="el" href="class_core_1_1_ref_counted.html" title="The common base class of Nebula.">Core::RefCounted</a> class and annotate the new class with some additional information in the class declaration and in the header file:</p>
<p>A normal RefCounted-derived class declaration usually looks like this:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>MyNamespace</div>
<div class="line">{</div>
<div class="line"><span class="keyword">class </span>MyClass : <span class="keyword">public</span> <a class="code hl_class" href="class_core_1_1_ref_counted.html">Core::RefCounted</a></div>
<div class="line">{</div>
<div class="line">    DeclareClass(MyClass);</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyClass();</div>
<div class="line">    <span class="keyword">virtual</span> ~MyClass();</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line">RegisterClass(MyClass);</div>
<div class="ttc" id="aclass_core_1_1_ref_counted_html"><div class="ttname"><a href="class_core_1_1_ref_counted.html">Core::RefCounted</a></div><div class="ttdoc">The common base class of Nebula.</div><div class="ttdef"><b>Definition</b> refcounted.h:38</div></div>
</div><!-- fragment --><p>Notice the DeclareClass() macro, the default constructor and the virtual destructor and the RegisterClass() macro outside of the class declaration. The DeclareClass() macro adds some minimal Nebula-specific information to the class declaration for the RTTI and factory mechanism. The DeclareClass() macro generally hides the internals of the <a class="el" href="namespace_nebula.html">Nebula</a> object model from the programmer, so that (hopefully), internals of the object model can be changed without affecting existing classes. The RegisterClass() macro is optional and registers the class with the central factory object. If you know that objects of this class will never be created by string class name or fourcc code, the RegisterClass() macro can be omitted.</p>
<p>The .cc side of the class needs to contain the following <a class="el" href="namespace_nebula.html">Nebula</a> specific information:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>MyNamespace</div>
<div class="line">{</div>
<div class="line">ImplementClass(MyNamespace::MyClass, <span class="stringliteral">&#39;MYCL&#39;</span>, <a class="code hl_class" href="class_core_1_1_ref_counted.html">Core::RefCounted</a>);</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>The ImplementClass() macro registers the class with the RTTI mechanism, the first parameter describes the C++ class name (note that the namespace must be present here. The second parameter is the class fourcc code, which must be unique across all classes (you'll get a runtime error at application startup if two classes try to register with the same fourcc code). The third parameter is the C++ class name of the parent class. This is used by the RTTI mechanism to reconstruct the class tree.</p>
<h2><a class="anchor" id="RefCountingAndSmartPointers"></a>
RefCounting And Smart Pointers</h2>
<p><a class="el" href="namespace_nebula.html">Nebula</a> uses traditional refcounting to manage the lifetime of its objects. A templated smart pointer class Ptr&lt;&gt; exists to hide the refcounting details from the programmer. As a general rule of thumb, always use smart pointers to point to RefCounted-derived objects unless you can make sure that within a given code block, the refcount of an object will not change.</p>
<p>Smart pointers have a number of advantages over plain pointers:</p>
<ul>
<li>accessing a 0-pointer will give you an easy to debug assertion instead of a memory fault</li>
<li>you'll never have to call AddRef() or Release() on you refcounted objects (in fact if you have, there's likely something seriously wrong)</li>
<li>smart pointers work nicely in container classes, an array of smart pointers instead of plain pointers eliminates all the typical lifetime management problems; you never need to take care about releasing the objects behind the pointers, instead the array just behaves like it would contain standard C++ objects</li>
<li>with smart pointers, you generally don't need to define "object ownership" as is often the case when using plain pointers (who's responsible to delete objects, and so on...)</li>
</ul>
<p>There are also some disadvantages with smart pointers:</p>
<ul>
<li>Performance: Copying and assigning smart pointers involves calling AddRef() and/or Release() on their objects, de-referencing a smart pointer involves an assertion-check that the contained object pointer is valid. The resulting performance hit is usually neglibe, but you may have to be aware of it in inner loops.</li>
<li>Presumably dead objects still alive: Since objects managed by smart pointers are only deleted when the last client gives up ownership, objects may exist longer then intended. Often this is points to a bug. <a class="el" href="namespace_nebula.html">Nebula</a> will notify you about any refcounting leaks (that is, refcounting objects that still exist at application shutdown)</li>
<li>Overuse of the RefCounted system might be a sign that your design is not data oriented. You should always consider if the object can be stack allocated and/or allocated as part of a larger allocation, instead of being allocated as an individual heap object.</li>
</ul>
<h2><a class="anchor" id="CreatingNebulaObjects"></a>
Creating Nebula Objects</h2>
<p><a class="el" href="namespace_nebula.html">Nebula</a> objects that are derived from <a class="el" href="class_core_1_1_ref_counted.html" title="The common base class of Nebula.">Core::RefCounted</a> can be created in 3 different ways:</p>
<p>Directly through the static create method: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_ptr.html">Ptr&lt;MyClass&gt;</a> myObj = MyClass::Create();</div>
<div class="ttc" id="aclass_ptr_html"><div class="ttname"><a href="class_ptr.html">Ptr</a></div><div class="ttdoc">Nebula's smart pointer class which manages the life time of RefCounted objects.</div><div class="ttdef"><b>Definition</b> ptr.h:38</div></div>
</div><!-- fragment --><p> The static Create() method is added to the class through the DeclareClass() macro described before. This is basically just syntactic sugar for the C++ operator::new(). In fact, the Create() method is nothing more then an inline method with a call to the new operator inside. Also note the correct use of a smart pointer to hold the new object.</p>
<p>Another way to create a <a class="el" href="namespace_nebula.html">Nebula</a> method is by class name: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_core.html">Core</a>;</div>
<div class="line"><a class="code hl_class" href="class_ptr.html">Ptr&lt;MyClass&gt;</a> myObj = (MyClass*) Factory::Instance()-&gt;Create(<span class="stringliteral">&quot;MyNamespace::MyClass&quot;</span>);</div>
<div class="ttc" id="anamespace_core_html"><div class="ttname"><a href="namespace_core.html">Core</a></div><div class="ttdef"><b>Definition</b> coreserver.cc:10</div></div>
</div><!-- fragment --><p> Creating an object by its string class name is useful if you don't know the object class at compile time, which is usually the case when serialized objects are restored, or when some sort of scripting interface is used. Note the type cast. This is necessary because the factory Create() method returns a generic pointer to a <a class="el" href="class_core_1_1_ref_counted.html" title="The common base class of Nebula.">Core::RefCounted</a> object.</p>
<p>A variation of the create-by-class-name method is to create the object by its class fourcc code: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_core.html">Core</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_util.html">Util</a>;</div>
<div class="line"><a class="code hl_class" href="class_ptr.html">Ptr&lt;MyClass&gt;</a> myObj = (MyClass*) Factory::Instance()-&gt;Create(<a class="code hl_class" href="class_util_1_1_four_c_c.html">FourCC</a>(<span class="stringliteral">&#39;MYCL&#39;</span>));</div>
<div class="ttc" id="aclass_util_1_1_four_c_c_html"><div class="ttname"><a href="class_util_1_1_four_c_c.html">Util::FourCC</a></div><div class="ttdoc">A four-character-code is a quasi-human-readable 32-bit-id.</div><div class="ttdef"><b>Definition</b> fourcc.h:19</div></div>
<div class="ttc" id="anamespace_util_html"><div class="ttname"><a href="namespace_util.html">Util</a></div><div class="ttdoc">A pinned array is an array which manages its own virtual memory.</div><div class="ttdef"><b>Definition</b> String.cs:6</div></div>
</div><!-- fragment --><p> This method looks less intuitive, but it is often faster as create-by-name and the fourcc class identifier uses less space (4 bytes) then the string class name, which may be of advantage when objects are encoded/decoded to and from binary streams.</p>
<h2><a class="anchor" id="NebulaRTTI"></a>
The Nebula Runtime Type Information System</h2>
<p>The <a class="el" href="namespace_nebula.html">Nebula</a> RTTI system gives you access to an objects class type at runtime and lets you check whether an object is the exact instance of a class, or an instance of a derived class. You can also get the class name or the class fourcc identifier directly from an object. All this functionality is implemented behind the scenes in the DeclareClass() and ImplementClass() macros. The RTTI mechanism is more efficient and easier to use then the RTTI mechanism in Nebula1 and Nebula2.</p>
<p>Here's some example code: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_util.html">Util</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_core.html">Core</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// check whether an object is instance of a specific class</span></div>
<div class="line"><span class="keywordflow">if</span> (myObj-&gt;IsInstanceOf(MyClass::RTTI))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// it&#39;s a MyClass object</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// check whether an object is instance of a derived class</span></div>
<div class="line"><span class="keywordflow">if</span> (myObj-&gt;IsA(RefCounted::RTTI))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// it&#39;s a RefCounted instance or some RefCounted-derived instance</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// get the class name of my object, this yields &quot;MyNamespace::MyClass&quot;</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="struct_util_1_1_string.html">String</a>&amp; className = myObj-&gt;GetClassName();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// get the fourcc class identifier of my object, this yields &#39;MYCL&#39;</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="class_util_1_1_four_c_c.html">FourCC</a>&amp; fourcc = myObj-&gt;GetClassFourCC();</div>
<div class="ttc" id="astruct_util_1_1_string_html"><div class="ttname"><a href="struct_util_1_1_string.html">Util.String</a></div><div class="ttdoc">Nebula's universal string class.</div><div class="ttdef"><b>Definition</b> String.cs:8</div></div>
</div><!-- fragment --><p>You can also query the central factory object whether a given class has been registered:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_core.html">Core</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// check if a class has been registered by class name</span></div>
<div class="line"><span class="keywordflow">if</span> (Factory::Instance()-&gt;ClassExists(<span class="stringliteral">&quot;MyNamespace::MyClass&quot;</span>))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// yep, the class exists</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// check if a class has been registered by class fourcc code</span></div>
<div class="line"><span class="keywordflow">if</span> (Factory::Instance()-&gt;ClassExists(<a class="code hl_class" href="class_util_1_1_four_c_c.html">FourCC</a>(<span class="stringliteral">&#39;MYCL&#39;</span>)))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// yep, the class exists</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="NebulaSingletons"></a>
Nebula Singletons</h2>
<p>Many central <a class="el" href="namespace_nebula.html">Nebula</a> objects are singletons, that is, an object which only exists once in the application and often is known to all other objects in the application.</p>
<p>Access to singleton objects can be gained through the static Instance() method, which returns a pointer to the single instance of the singleton class. The returned pointer is guaranteed to be valid. If the singleton object doesn't exist at the time the Instance() method is called, an assertion will be thrown:</p>
<div class="fragment"><div class="line"><span class="comment">// obtain a pointer to the Core::Server singleton</span></div>
<div class="line"><a class="code hl_class" href="class_ptr.html">Ptr&lt;Core::Server&gt;</a> coreServer = Core::Server::Instance();</div>
</div><!-- fragment --><p>You can also check for the existance of a given singleton: </p><div class="fragment"><div class="line"><span class="comment">// does the Core::Server object exist?</span></div>
<div class="line"><span class="keywordflow">if</span> (Core::Server::HasInstance())</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// yep, the core server exists</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="namespace_nebula.html">Nebula</a> provides some helper macros to implement a singleton class:</p>
<div class="fragment"><div class="line"><span class="comment">// declare a singleton class</span></div>
<div class="line"><span class="keyword">class </span>MySingletonClass : <span class="keyword">public</span> <a class="code hl_class" href="class_core_1_1_ref_counted.html">Core::RefCounted</a></div>
<div class="line">{</div>
<div class="line">    DeclareClass(MySingletonClass);</div>
<div class="line">    DeclareSingleton(MySingletonClass);</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MySingletonClass();</div>
<div class="line">    <span class="keyword">virtual</span> ~MySingletonClass();</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// implement the singleton class</span></div>
<div class="line">ImplementClass(MyNamespace::MySingletonClass, <span class="stringliteral">&#39;MYSC&#39;</span>, <a class="code hl_class" href="class_core_1_1_ref_counted.html">Core::RefCounted</a>);</div>
<div class="line">ImplementSingleton(MyNamespace::MySingletonClass);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line">MySingletonClass::MySingletonClass()</div>
<div class="line">{</div>
<div class="line">    ConstructSingleton;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line">MySingletonClass:~MySingletonClass()</div>
<div class="line">{</div>
<div class="line">    DestructSingleton;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The DeclareSingleton() and ImplementSingleton() macros are similar to the DeclareClass() and ImplementClass() macros. They add some static methods to the class (namely the Instance() and HasInstance() methods). The constructor and destructor of the class must contain a <b>ConstructSingleton</b> and <b>DestructSingleton</b> macros. ConstructSingleton initializes a private static singleton pointer and makes sure that no other instance of the class exists (otherwise, an assertion will be thrown). DestructSingleton invalidates the static singleton pointer.</p>
<p>Access to singletons is by default thread-local. This means that a singleton created in one thread of a <a class="el" href="namespace_nebula.html">Nebula</a> application isn't accessible from another thread.</p>
<h2><a class="anchor" id="CorePerfAndMemConsideratins"></a>
Performance And Memory Footprint Considerations</h2>
<p>One of the design goals of the <a class="el" href="namespace_nebula.html">Nebula</a> <a class="el" href="namespace_core.html">Core</a> Layer was to reduce the memory footprint of low level code to make the system better suited for small host platforms like handheld consoles (and a small memory footprint doesn't hurt on bigger platforms either). Here are some points how these goals are accomplished:</p>
<ul>
<li>The RefCounted class just adds 4 bytes per-instance data for the reference count member, Nebula2's nRoot class added &gt;60 bytes overhead to each instance.</li>
<li>The RTTI mechanism adds somewhere between 30 and 60 bytes overhead, but this is per-class, not per instance.</li>
<li>A smart pointer is just the size of a regular pointer, just like a raw pointer. The similar Nebula2 nRef class was 16 bytes per instance.</li>
<li>Several householding structures are only allocated in debug mode, most notably the RefCountedList, which is used to detect refcounting leaks.</li>
</ul>
<p>Here are some timings for creating a million RefCounted objects by the 3 different ways. These timings are on a notebook with Intel Pentium M running at 800 MHz:</p>
<ul>
<li>Create(): 0.29 seconds</li>
<li>by FourCC: 0.65 seconds</li>
<li>by class name: 1.45 seconds </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
		<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
			<ul>
				<li class="navelem"><a class="el" href="foundation.html">Foundation Libraries</a></li>
				<li class="footer">
					Generated on Wed Mar 27 2024 19:04:40 for Nebula. Dark theme by <a href="http://majerle.eu" target="_new">Tilen Majerle</a>. All rights reserved.
				</li>
			</ul>
		</div>
		<script src="custom.js"></script>
	</body>
</html>
