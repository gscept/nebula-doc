<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<meta name="generator" content="Doxygen 1.10.0"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>Nebula: /github/workspace/code/foundation/util/tupleutility.h File Reference</title>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
			<table cellspacing="0" cellpadding="0">
				<tbody>
					<tr style="height: 56px;">
						<td id="projectalign" style="padding-left: 0.5em;">
							<div id="projectname">Nebula
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part --><!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('tupleutility_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">tupleutility.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;tuple&gt;</code><br />
</div>
<p><a href="tupleutility_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_util_1_1get__template__type_3_01_c_3_01_t_01_4_01_4.html">Util::get_template_type&lt; C&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get inner type of two types.  <a href="struct_util_1_1get__template__type_3_01_c_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_util_1_1get__template__type_3_01_c_3_01_t_00_01_i_01_4_01_4.html">Util::get_template_type&lt; C&lt; T, I &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get inner type of two types.  <a href="struct_util_1_1get__template__type_3_01_c_3_01_t_00_01_i_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_util_1_1get__template__type_3_01_c_3_01_i_00_01_t_01_4_01_4.html">Util::get_template_type&lt; C&lt; I, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get inner type of two types.  <a href="struct_util_1_1get__template__type_3_01_c_3_01_i_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_util_1_1get__template__type_3_01const_01_c_3_01_t_01_4_01_6_01_4.html">Util::get_template_type&lt; const C&lt; T &gt; &amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get inner type of a constant ref outer type.  <a href="struct_util_1_1get__template__type_3_01const_01_c_3_01_t_01_4_01_6_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_util_1_1get__template__type_3_01_c_3_01_i_00_01_t_01_4_01_6_01_4.html">Util::get_template_type&lt; C&lt; I, T &gt; &amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get inner type of two types.  <a href="struct_util_1_1get__template__type_3_01_c_3_01_i_00_01_t_01_4_01_6_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_util_1_1get__template__type_3_01_c_3_01_t_00_01_i_01_4_01_6_01_4.html">Util::get_template_type&lt; C&lt; T, I &gt; &amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get inner type of two types.  <a href="struct_util_1_1get__template__type_3_01_c_3_01_t_00_01_i_01_4_01_6_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_util" id="r_namespace_util"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_util.html">Util</a></td></tr>
<tr class="memdesc:namespace_util"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pinned array is an array which manages its own virtual memory. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad8f63293b6e3a30890b850ecb295f53f" id="r_ad8f63293b6e3a30890b850ecb295f53f"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ad8f63293b6e3a30890b850ecb295f53f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#ad8f63293b6e3a30890b850ecb295f53f">Util::Tuple</a> = std::tuple&lt;T...&gt;</td></tr>
<tr class="memdesc:ad8f63293b6e3a30890b850ecb295f53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap std::tuple.  <br /></td></tr>
<tr class="separator:ad8f63293b6e3a30890b850ecb295f53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8e46504284e2b7fda1b3dc21a510c3" id="r_afc8e46504284e2b7fda1b3dc21a510c3"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:afc8e46504284e2b7fda1b3dc21a510c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#afc8e46504284e2b7fda1b3dc21a510c3">Util::Pair</a> = std::pair&lt;A, B&gt;</td></tr>
<tr class="memdesc:afc8e46504284e2b7fda1b3dc21a510c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap std::pair.  <br /></td></tr>
<tr class="separator:afc8e46504284e2b7fda1b3dc21a510c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c0ba58693827acd3c85fff898c00e6" id="r_ae1c0ba58693827acd3c85fff898c00e6"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:ae1c0ba58693827acd3c85fff898c00e6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#ae1c0ba58693827acd3c85fff898c00e6">Util::get_template_type_t</a> = typename <a class="el" href="struct_util_1_1get__template__type.html">get_template_type</a>&lt;C&gt;::type</td></tr>
<tr class="memdesc:ae1c0ba58693827acd3c85fff898c00e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper typedef so that the above expression can be used like decltype.  <br /></td></tr>
<tr class="separator:ae1c0ba58693827acd3c85fff898c00e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727242ef4571513f2628ad972baf2183" id="r_a727242ef4571513f2628ad972baf2183"><td class="memTemplParams" colspan="2">template&lt;int MEMBER, class ... TYPES&gt; </td></tr>
<tr class="memitem:a727242ef4571513f2628ad972baf2183"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a727242ef4571513f2628ad972baf2183">Util::tuple_array_t</a> = <a class="el" href="namespace_util.html#ae1c0ba58693827acd3c85fff898c00e6">get_template_type_t</a>&lt;std::tuple_element_t&lt;MEMBER, std::tuple&lt;<a class="el" href="class_util_1_1_array.html">Util::Array</a>&lt;TYPES&gt;...&gt;&gt;&gt;</td></tr>
<tr class="memdesc:a727242ef4571513f2628ad972baf2183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type of contained element in <a class="el" href="class_util_1_1_array.html" title="Nebula&#39;s dynamic array class.">Util::Array</a> stored in std::tuple.  <br /></td></tr>
<tr class="separator:a727242ef4571513f2628ad972baf2183"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a51c0e64fce7a99558534d3911051660b" id="r_a51c0e64fce7a99558534d3911051660b"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a51c0e64fce7a99558534d3911051660b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_util.html#ad8f63293b6e3a30890b850ecb295f53f">Tuple</a>&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a51c0e64fce7a99558534d3911051660b">Util::MakeTuple</a> (const T &amp;... args)</td></tr>
<tr class="separator:a51c0e64fce7a99558534d3911051660b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f12d477cb3fa493872f1af0e406db0" id="r_a47f12d477cb3fa493872f1af0e406db0"><td class="memTemplParams" colspan="2">template&lt;int INDEX, typename... T&gt; </td></tr>
<tr class="memitem:a47f12d477cb3fa493872f1af0e406db0"><td class="memTemplItemLeft" align="right" valign="top">constexpr const std::tuple_element_t&lt; INDEX, std::tuple&lt; T... &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a47f12d477cb3fa493872f1af0e406db0">Util::Get</a> (const <a class="el" href="namespace_util.html#ad8f63293b6e3a30890b850ecb295f53f">Tuple</a>&lt; T... &gt; &amp;tuple)</td></tr>
<tr class="separator:a47f12d477cb3fa493872f1af0e406db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2663641470c1ec3e4a9c821e9115e45a" id="r_a2663641470c1ec3e4a9c821e9115e45a"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a2663641470c1ec3e4a9c821e9115e45a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_util.html#afc8e46504284e2b7fda1b3dc21a510c3">Pair</a>&lt; A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a2663641470c1ec3e4a9c821e9115e45a">Util::MakePair</a> (const A &amp;a, const B &amp;b)</td></tr>
<tr class="separator:a2663641470c1ec3e4a9c821e9115e45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208e3264d2d945b9dfcc34b6cf728efc" id="r_a208e3264d2d945b9dfcc34b6cf728efc"><td class="memTemplParams" colspan="2">template&lt;int INDEX, typename A , typename B &gt; </td></tr>
<tr class="memitem:a208e3264d2d945b9dfcc34b6cf728efc"><td class="memTemplItemLeft" align="right" valign="top">constexpr const std::tuple_element_t&lt; INDEX, std::tuple&lt; A, B &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a208e3264d2d945b9dfcc34b6cf728efc">Util::Get</a> (const <a class="el" href="namespace_util.html#afc8e46504284e2b7fda1b3dc21a510c3">Pair</a>&lt; A, B &gt; &amp;pair)</td></tr>
<tr class="separator:a208e3264d2d945b9dfcc34b6cf728efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3158c18bad3c53f6b28e106254d1bd99" id="r_a3158c18bad3c53f6b28e106254d1bd99"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is&gt; </td></tr>
<tr class="memitem:a3158c18bad3c53f6b28e106254d1bd99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a3158c18bad3c53f6b28e106254d1bd99">Util::alloc_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:a3158c18bad3c53f6b28e106254d1bd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks allocations for each member in a tuble.  <br /></td></tr>
<tr class="separator:a3158c18bad3c53f6b28e106254d1bd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cff58ce5395906b4582f60064540e9d" id="r_a3cff58ce5395906b4582f60064540e9d"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a3cff58ce5395906b4582f60064540e9d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a3cff58ce5395906b4582f60064540e9d">Util::alloc_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:a3cff58ce5395906b4582f60064540e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for above expansion function.  <br /></td></tr>
<tr class="separator:a3cff58ce5395906b4582f60064540e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ba272acc88b6fd748bbb8a87898e26" id="r_a33ba272acc88b6fd748bbb8a87898e26"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is&gt; </td></tr>
<tr class="memitem:a33ba272acc88b6fd748bbb8a87898e26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a33ba272acc88b6fd748bbb8a87898e26">Util::clear_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:a33ba272acc88b6fd748bbb8a87898e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks allocations for each member in a tuple.  <br /></td></tr>
<tr class="separator:a33ba272acc88b6fd748bbb8a87898e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac523806fb17029f288ac10791bbc7b00" id="r_ac523806fb17029f288ac10791bbc7b00"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:ac523806fb17029f288ac10791bbc7b00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#ac523806fb17029f288ac10791bbc7b00">Util::clear_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:ac523806fb17029f288ac10791bbc7b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for above expansion function.  <br /></td></tr>
<tr class="separator:ac523806fb17029f288ac10791bbc7b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7a31bf982926a6211fe93fd169da5e" id="r_a0b7a31bf982926a6211fe93fd169da5e"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is&gt; </td></tr>
<tr class="memitem:a0b7a31bf982926a6211fe93fd169da5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a0b7a31bf982926a6211fe93fd169da5e">Util::move_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t to, uint32_t from, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:a0b7a31bf982926a6211fe93fd169da5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for moving an element between two indices.  <br /></td></tr>
<tr class="separator:a0b7a31bf982926a6211fe93fd169da5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bc91449daa6b35f6afdee2077e970d" id="r_ae6bc91449daa6b35f6afdee2077e970d"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:ae6bc91449daa6b35f6afdee2077e970d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#ae6bc91449daa6b35f6afdee2077e970d">Util::move_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t to, uint32_t from)</td></tr>
<tr class="memdesc:ae6bc91449daa6b35f6afdee2077e970d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for moving an element between two indices.  <br /></td></tr>
<tr class="separator:ae6bc91449daa6b35f6afdee2077e970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168f16fd3a8fda426003a736f5271eb9" id="r_a168f16fd3a8fda426003a736f5271eb9"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is&gt; </td></tr>
<tr class="memitem:a168f16fd3a8fda426003a736f5271eb9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a168f16fd3a8fda426003a736f5271eb9">Util::erase_index_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t i, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:a168f16fd3a8fda426003a736f5271eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for erasing an element.  <br /></td></tr>
<tr class="separator:a168f16fd3a8fda426003a736f5271eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75aaffc78fa4b60acc0eab3048a67a1" id="r_af75aaffc78fa4b60acc0eab3048a67a1"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:af75aaffc78fa4b60acc0eab3048a67a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#af75aaffc78fa4b60acc0eab3048a67a1">Util::erase_index_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t i)</td></tr>
<tr class="memdesc:af75aaffc78fa4b60acc0eab3048a67a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for erasing an element.  <br /></td></tr>
<tr class="separator:af75aaffc78fa4b60acc0eab3048a67a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2694582e9f28c42d2a9a232f0b5ecb3" id="r_ad2694582e9f28c42d2a9a232f0b5ecb3"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is&gt; </td></tr>
<tr class="memitem:ad2694582e9f28c42d2a9a232f0b5ecb3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#ad2694582e9f28c42d2a9a232f0b5ecb3">Util::erase_index_swap_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t i, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:ad2694582e9f28c42d2a9a232f0b5ecb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for erasing an element by swapping with the last and reducing size.  <br /></td></tr>
<tr class="separator:ad2694582e9f28c42d2a9a232f0b5ecb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf36a01a5e4d697e89d1e9c96a333ac" id="r_aabf36a01a5e4d697e89d1e9c96a333ac"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:aabf36a01a5e4d697e89d1e9c96a333ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#aabf36a01a5e4d697e89d1e9c96a333ac">Util::erase_index_swap_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t i)</td></tr>
<tr class="memdesc:aabf36a01a5e4d697e89d1e9c96a333ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for erasing an element by swapping with the last and reducing size.  <br /></td></tr>
<tr class="separator:aabf36a01a5e4d697e89d1e9c96a333ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc7f181637b51cb64ae41b54c94990d" id="r_a0cc7f181637b51cb64ae41b54c94990d"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is&gt; </td></tr>
<tr class="memitem:a0cc7f181637b51cb64ae41b54c94990d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a0cc7f181637b51cb64ae41b54c94990d">Util::erase_range_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t start, uint32_t end, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="separator:a0cc7f181637b51cb64ae41b54c94990d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b9c095e9e62c3bdb32ba0f821d40ce" id="r_ad7b9c095e9e62c3bdb32ba0f821d40ce"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:ad7b9c095e9e62c3bdb32ba0f821d40ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#ad7b9c095e9e62c3bdb32ba0f821d40ce">Util::erase_range_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t start, uint32_t end)</td></tr>
<tr class="memdesc:ad7b9c095e9e62c3bdb32ba0f821d40ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for erasing a range of elements the last and reducing size.  <br /></td></tr>
<tr class="separator:ad7b9c095e9e62c3bdb32ba0f821d40ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9f61b2d8d27bd199cf5d9b3b7902c4" id="r_a6b9f61b2d8d27bd199cf5d9b3b7902c4"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is, class... TYPES&gt; </td></tr>
<tr class="memitem:a6b9f61b2d8d27bd199cf5d9b3b7902c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a6b9f61b2d8d27bd199cf5d9b3b7902c4">Util::set_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t i, std::index_sequence&lt; Is... &gt;, TYPES const &amp;... values)</td></tr>
<tr class="memdesc:a6b9f61b2d8d27bd199cf5d9b3b7902c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for setting values in each array at an index.  <br /></td></tr>
<tr class="separator:a6b9f61b2d8d27bd199cf5d9b3b7902c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ee071178937aed8148ce1b5fb46ea7" id="r_a62ee071178937aed8148ce1b5fb46ea7"><td class="memTemplParams" colspan="2">template&lt;class... Ts, class... TYPES&gt; </td></tr>
<tr class="memitem:a62ee071178937aed8148ce1b5fb46ea7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a62ee071178937aed8148ce1b5fb46ea7">Util::set_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t i, TYPES const &amp;... values)</td></tr>
<tr class="memdesc:a62ee071178937aed8148ce1b5fb46ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for setting values in each array at an index.  <br /></td></tr>
<tr class="separator:a62ee071178937aed8148ce1b5fb46ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249e9aa97205b1b12c17aefd3b07df65" id="r_a249e9aa97205b1b12c17aefd3b07df65"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is&gt; </td></tr>
<tr class="memitem:a249e9aa97205b1b12c17aefd3b07df65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a249e9aa97205b1b12c17aefd3b07df65">Util::reserve_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t size, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:a249e9aa97205b1b12c17aefd3b07df65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for reserving in each array.  <br /></td></tr>
<tr class="separator:a249e9aa97205b1b12c17aefd3b07df65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804384bbbdcd9f697e89b2bc86b15fba" id="r_a804384bbbdcd9f697e89b2bc86b15fba"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a804384bbbdcd9f697e89b2bc86b15fba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a804384bbbdcd9f697e89b2bc86b15fba">Util::reserve_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t size)</td></tr>
<tr class="memdesc:a804384bbbdcd9f697e89b2bc86b15fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for reserving in each array.  <br /></td></tr>
<tr class="separator:a804384bbbdcd9f697e89b2bc86b15fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0e576da37feb940e959259ba7751d2" id="r_adb0e576da37feb940e959259ba7751d2"><td class="memTemplParams" colspan="2">template&lt;class... Ts, std::size_t... Is&gt; </td></tr>
<tr class="memitem:adb0e576da37feb940e959259ba7751d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#adb0e576da37feb940e959259ba7751d2">Util::set_size_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t size, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:adb0e576da37feb940e959259ba7751d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for reserving in each array.  <br /></td></tr>
<tr class="separator:adb0e576da37feb940e959259ba7751d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c334f60eb2cdfdf2e9272804e012a34" id="r_a0c334f60eb2cdfdf2e9272804e012a34"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a0c334f60eb2cdfdf2e9272804e012a34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_util.html#a0c334f60eb2cdfdf2e9272804e012a34">Util::set_size_for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; &amp;tuple, uint32_t size)</td></tr>
<tr class="memdesc:a0c334f60eb2cdfdf2e9272804e012a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for reserving in each array.  <br /></td></tr>
<tr class="separator:a0c334f60eb2cdfdf2e9272804e012a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
		<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
			<ul>
				<li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_95721ede6f5af11f857e00d39fc9cf1f.html">foundation</a></li><li class="navelem"><a class="el" href="dir_3efd1eb2182038baf5731b057d5f9c3b.html">util</a></li><li class="navelem"><a class="el" href="tupleutility_8h.html">tupleutility.h</a></li>
				<li class="footer">
					Generated on Thu Mar 21 2024 09:47:36 for Nebula. Dark theme by <a href="http://majerle.eu" target="_new">Tilen Majerle</a>. All rights reserved.
				</li>
			</ul>
		</div>
		<script src="custom.js"></script>
	</body>
</html>
