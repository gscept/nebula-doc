<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<meta name="generator" content="Doxygen 1.10.0"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>Nebula: Util::ArrayStack&lt; TYPE, STACK_SIZE &gt; Class Template Reference</title>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
			<table cellspacing="0" cellpadding="0">
				<tbody>
					<tr style="height: 56px;">
						<td id="projectalign" style="padding-left: 0.5em;">
							<div id="projectname">Nebula
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part --><!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_util_1_1_array_stack.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="class_util_1_1_array_stack-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Util::ArrayStack&lt; TYPE, STACK_SIZE &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="arraystack_8h_source.html">arraystack.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class TYPE, int STACK_SIZE&gt;<br />
class Util::ArrayStack&lt; TYPE, STACK_SIZE &gt;</div><p><a class="el" href="namespace_nebula.html">Nebula</a>'s small vector optimized array. </p>
<p>Identical to <a class="el" href="class_util_1_1_array.html" title="Nebula&#39;s dynamic array class.">Array</a> in every way except that it keeps a stack allocated small buffer (much like <a class="el" href="struct_util_1_1_string.html" title="Nebula&#39;s universal string class.">String</a>) and can allow for arrays to be tightly packed in memory.</p>
<p>Presented at CppCon 2016: <a href="https://www.youtube.com/watch?v=vElZc6zSIXM">https://www.youtube.com/watch?v=vElZc6zSIXM</a></p>
<dl class="section copyright"><dt>Copyright</dt><dd>(C) 2018-2020 Individual contributors, see AUTHORS file </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aed444fe3290d1b9c0c16f145502201e9" id="r_aed444fe3290d1b9c0c16f145502201e9"><td class="memItemLeft" align="right" valign="top">typedef TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">Iterator</a></td></tr>
<tr class="memdesc:aed444fe3290d1b9c0c16f145502201e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">define iterator  <br /></td></tr>
<tr class="separator:aed444fe3290d1b9c0c16f145502201e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a69799b7ac144dbfd06fa28c11fe89350" id="r_a69799b7ac144dbfd06fa28c11fe89350"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69799b7ac144dbfd06fa28c11fe89350">ArrayStack</a> ()</td></tr>
<tr class="memdesc:a69799b7ac144dbfd06fa28c11fe89350"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor with default parameters  <br /></td></tr>
<tr class="separator:a69799b7ac144dbfd06fa28c11fe89350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d94b271c968f8b74461951a4ece728" id="r_aa2d94b271c968f8b74461951a4ece728"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2d94b271c968f8b74461951a4ece728">ArrayStack</a> (<a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> initialCapacity, <a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> initialGrow)</td></tr>
<tr class="memdesc:aa2d94b271c968f8b74461951a4ece728"><td class="mdescLeft">&#160;</td><td class="mdescRight">constuctor with initial size and grow size  <br /></td></tr>
<tr class="separator:aa2d94b271c968f8b74461951a4ece728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6c93119621e1be3fef5c5a7f70a03b" id="r_a2f6c93119621e1be3fef5c5a7f70a03b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f6c93119621e1be3fef5c5a7f70a03b">ArrayStack</a> (<a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> initialSize, <a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> initialGrow, const TYPE &amp;initialValue)</td></tr>
<tr class="memdesc:a2f6c93119621e1be3fef5c5a7f70a03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor with initial size, grow size and initial values  <br /></td></tr>
<tr class="separator:a2f6c93119621e1be3fef5c5a7f70a03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6799725898c8c2652b281b2d604388ef" id="r_a6799725898c8c2652b281b2d604388ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6799725898c8c2652b281b2d604388ef">ArrayStack</a> (const <a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6799725898c8c2652b281b2d604388ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <br /></td></tr>
<tr class="separator:a6799725898c8c2652b281b2d604388ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9006a300fd3a18624a3ad653ac9659cb" id="r_a9006a300fd3a18624a3ad653ac9659cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9006a300fd3a18624a3ad653ac9659cb">ArrayStack</a> (<a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:a9006a300fd3a18624a3ad653ac9659cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor  <br /></td></tr>
<tr class="separator:a9006a300fd3a18624a3ad653ac9659cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43058b28e64cf8084cd69c33a63745cb" id="r_a43058b28e64cf8084cd69c33a63745cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43058b28e64cf8084cd69c33a63745cb">ArrayStack</a> (std::initializer_list&lt; TYPE &gt; list)</td></tr>
<tr class="memdesc:a43058b28e64cf8084cd69c33a63745cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor from initializer list  <br /></td></tr>
<tr class="separator:a43058b28e64cf8084cd69c33a63745cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a430d0ee2f77e396ae2085a554f1de" id="r_ae5a430d0ee2f77e396ae2085a554f1de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5a430d0ee2f77e396ae2085a554f1de">~ArrayStack</a> ()</td></tr>
<tr class="memdesc:ae5a430d0ee2f77e396ae2085a554f1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <br /></td></tr>
<tr class="separator:ae5a430d0ee2f77e396ae2085a554f1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56eb882dce5807bab737d3f39dc1897e" id="r_a56eb882dce5807bab737d3f39dc1897e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56eb882dce5807bab737d3f39dc1897e">operator=</a> (const <a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a56eb882dce5807bab737d3f39dc1897e"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment operator  <br /></td></tr>
<tr class="separator:a56eb882dce5807bab737d3f39dc1897e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba9b50a81a5476179a120b1a1773291" id="r_a0ba9b50a81a5476179a120b1a1773291"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ba9b50a81a5476179a120b1a1773291">operator=</a> (<a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:a0ba9b50a81a5476179a120b1a1773291"><td class="mdescLeft">&#160;</td><td class="mdescRight">move operator  <br /></td></tr>
<tr class="separator:a0ba9b50a81a5476179a120b1a1773291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fc39fa91ad39db9f5333d2699950c4" id="r_a32fc39fa91ad39db9f5333d2699950c4"><td class="memItemLeft" align="right" valign="top">TYPE &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32fc39fa91ad39db9f5333d2699950c4">operator[]</a> (<a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> index) const</td></tr>
<tr class="memdesc:a32fc39fa91ad39db9f5333d2699950c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">[] operator  <br /></td></tr>
<tr class="separator:a32fc39fa91ad39db9f5333d2699950c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ac621d1fc25574bc2e24ef9c39dc6e" id="r_ad0ac621d1fc25574bc2e24ef9c39dc6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0ac621d1fc25574bc2e24ef9c39dc6e">operator==</a> (const <a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:ad0ac621d1fc25574bc2e24ef9c39dc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">equality operator  <br /></td></tr>
<tr class="separator:ad0ac621d1fc25574bc2e24ef9c39dc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b517266cba92cdc4fccb79e5c898d43" id="r_a8b517266cba92cdc4fccb79e5c898d43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b517266cba92cdc4fccb79e5c898d43">operator!=</a> (const <a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a8b517266cba92cdc4fccb79e5c898d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">inequality operator  <br /></td></tr>
<tr class="separator:a8b517266cba92cdc4fccb79e5c898d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda541e3abf746bad70bc55ac8f44227" id="r_abda541e3abf746bad70bc55ac8f44227"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abda541e3abf746bad70bc55ac8f44227"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abda541e3abf746bad70bc55ac8f44227">As</a> () const</td></tr>
<tr class="memdesc:abda541e3abf746bad70bc55ac8f44227"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert to "anything"  <br /></td></tr>
<tr class="separator:abda541e3abf746bad70bc55ac8f44227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633a1fcb9d8ec727e618e7bdd5d755da" id="r_a633a1fcb9d8ec727e618e7bdd5d755da"><td class="memTemplParams" colspan="2">template&lt;typename ... ELEM_TYPE&gt; </td></tr>
<tr class="memitem:a633a1fcb9d8ec727e618e7bdd5d755da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a633a1fcb9d8ec727e618e7bdd5d755da">Append</a> (const TYPE &amp;first, const ELEM_TYPE &amp;... <a class="el" href="#a95e4a68324a4a081cc8a4160a5479e46">elements</a>)</td></tr>
<tr class="memdesc:a633a1fcb9d8ec727e618e7bdd5d755da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append multiple elements to the end of the array.  <br /></td></tr>
<tr class="separator:a633a1fcb9d8ec727e618e7bdd5d755da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd2920e7c447e623105a05df9c4855d" id="r_abfd2920e7c447e623105a05df9c4855d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfd2920e7c447e623105a05df9c4855d">Append</a> (const TYPE &amp;elm)</td></tr>
<tr class="memdesc:abfd2920e7c447e623105a05df9c4855d"><td class="mdescLeft">&#160;</td><td class="mdescRight">append element to end of array  <br /></td></tr>
<tr class="separator:abfd2920e7c447e623105a05df9c4855d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eccc1033ab1257c7f037e6db2ab19b5" id="r_a3eccc1033ab1257c7f037e6db2ab19b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3eccc1033ab1257c7f037e6db2ab19b5">Append</a> (TYPE &amp;&amp;elm)</td></tr>
<tr class="memdesc:a3eccc1033ab1257c7f037e6db2ab19b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">append an element which is being forwarded  <br /></td></tr>
<tr class="separator:a3eccc1033ab1257c7f037e6db2ab19b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763499ceb1daa406a2e04dab17a720fb" id="r_a763499ceb1daa406a2e04dab17a720fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a763499ceb1daa406a2e04dab17a720fb">AppendArray</a> (const <a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a763499ceb1daa406a2e04dab17a720fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">append the contents of an array to this array  <br /></td></tr>
<tr class="separator:a763499ceb1daa406a2e04dab17a720fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b3304327830a0ffb815b0e521f60eb" id="r_a87b3304327830a0ffb815b0e521f60eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87b3304327830a0ffb815b0e521f60eb">AppendArray</a> (const TYPE *arr, const <a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> <a class="el" href="#a7ff154ddd458ac3bfcea6780aba95181">count</a>)</td></tr>
<tr class="memdesc:a87b3304327830a0ffb815b0e521f60eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">append from C array  <br /></td></tr>
<tr class="separator:a87b3304327830a0ffb815b0e521f60eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c736efed4e19139cf9dca169305727d" id="r_a9c736efed4e19139cf9dca169305727d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c736efed4e19139cf9dca169305727d">Reserve</a> (<a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> num)</td></tr>
<tr class="memdesc:a9c736efed4e19139cf9dca169305727d"><td class="mdescLeft">&#160;</td><td class="mdescRight">increase capacity to fit N more elements into the array  <br /></td></tr>
<tr class="separator:a9c736efed4e19139cf9dca169305727d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74cee49eca92ea93f4d3f8ffbf791ac" id="r_ae74cee49eca92ea93f4d3f8ffbf791ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae74cee49eca92ea93f4d3f8ffbf791ac">Size</a> () const</td></tr>
<tr class="memdesc:ae74cee49eca92ea93f4d3f8ffbf791ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">get number of elements in array  <br /></td></tr>
<tr class="separator:ae74cee49eca92ea93f4d3f8ffbf791ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5805c0b9f0cf732225332b5b9561ec9" id="r_ab5805c0b9f0cf732225332b5b9561ec9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5805c0b9f0cf732225332b5b9561ec9">ByteSize</a> () const</td></tr>
<tr class="memdesc:ab5805c0b9f0cf732225332b5b9561ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the byte size of the array.  <br /></td></tr>
<tr class="separator:ab5805c0b9f0cf732225332b5b9561ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f66cf42e93016761c7f8f0521c1833" id="r_ab3f66cf42e93016761c7f8f0521c1833"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3f66cf42e93016761c7f8f0521c1833">Capacity</a> () const</td></tr>
<tr class="memdesc:ab3f66cf42e93016761c7f8f0521c1833"><td class="mdescLeft">&#160;</td><td class="mdescRight">get overall allocated size of array in number of elements  <br /></td></tr>
<tr class="separator:ab3f66cf42e93016761c7f8f0521c1833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10437288095b2efb90bb554d342fb86" id="r_ab10437288095b2efb90bb554d342fb86"><td class="memItemLeft" align="right" valign="top">TYPE &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab10437288095b2efb90bb554d342fb86">Front</a> () const</td></tr>
<tr class="memdesc:ab10437288095b2efb90bb554d342fb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">return reference to first element  <br /></td></tr>
<tr class="separator:ab10437288095b2efb90bb554d342fb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d4e460efc6c0d11c314e2a9556f5ef" id="r_ae0d4e460efc6c0d11c314e2a9556f5ef"><td class="memItemLeft" align="right" valign="top">TYPE &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0d4e460efc6c0d11c314e2a9556f5ef">Back</a> () const</td></tr>
<tr class="memdesc:ae0d4e460efc6c0d11c314e2a9556f5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">return reference to last element  <br /></td></tr>
<tr class="separator:ae0d4e460efc6c0d11c314e2a9556f5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e94be31aa8a403ca746f53d875cedfa" id="r_a8e94be31aa8a403ca746f53d875cedfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e94be31aa8a403ca746f53d875cedfa">IsEmpty</a> () const</td></tr>
<tr class="memdesc:a8e94be31aa8a403ca746f53d875cedfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if array empty  <br /></td></tr>
<tr class="separator:a8e94be31aa8a403ca746f53d875cedfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef691cba5741b53bf292aeb632d6d42" id="r_a7ef691cba5741b53bf292aeb632d6d42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ef691cba5741b53bf292aeb632d6d42">EraseIndex</a> (<a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> index)</td></tr>
<tr class="memdesc:a7ef691cba5741b53bf292aeb632d6d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase element at index, keep sorting intact  <br /></td></tr>
<tr class="separator:a7ef691cba5741b53bf292aeb632d6d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9be93fa632dbad512edc4f593b4af5" id="r_afd9be93fa632dbad512edc4f593b4af5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd9be93fa632dbad512edc4f593b4af5">Erase</a> (<a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">Iterator</a> iter)</td></tr>
<tr class="memdesc:afd9be93fa632dbad512edc4f593b4af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase element pointed to by iterator, keep sorting intact  <br /></td></tr>
<tr class="separator:afd9be93fa632dbad512edc4f593b4af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad95c749874686f63627225bc7138b6" id="r_adad95c749874686f63627225bc7138b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adad95c749874686f63627225bc7138b6">EraseIndexSwap</a> (<a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> index)</td></tr>
<tr class="memdesc:adad95c749874686f63627225bc7138b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase element at index, fill gap by swapping in last element, destroys sorting!  <br /></td></tr>
<tr class="separator:adad95c749874686f63627225bc7138b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68535f93e92d5a5f874b02948cc9ff83" id="r_a68535f93e92d5a5f874b02948cc9ff83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68535f93e92d5a5f874b02948cc9ff83">EraseSwap</a> (<a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">Iterator</a> iter)</td></tr>
<tr class="memdesc:a68535f93e92d5a5f874b02948cc9ff83"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase element at iterator, fill gap by swapping in last element, destroys sorting!  <br /></td></tr>
<tr class="separator:a68535f93e92d5a5f874b02948cc9ff83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f150a7355d99fe4b2ba9bfc2fee185" id="r_aa9f150a7355d99fe4b2ba9bfc2fee185"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9f150a7355d99fe4b2ba9bfc2fee185">EraseBack</a> ()</td></tr>
<tr class="memdesc:aa9f150a7355d99fe4b2ba9bfc2fee185"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase last element  <br /></td></tr>
<tr class="separator:aa9f150a7355d99fe4b2ba9bfc2fee185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0eb3c5bd69dbd866349f508a200cd7" id="r_a4f0eb3c5bd69dbd866349f508a200cd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f0eb3c5bd69dbd866349f508a200cd7">EraseFront</a> ()</td></tr>
<tr class="memdesc:a4f0eb3c5bd69dbd866349f508a200cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase first element  <br /></td></tr>
<tr class="separator:a4f0eb3c5bd69dbd866349f508a200cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1561d381b2e1ed0b2f698456b9093b6" id="r_af1561d381b2e1ed0b2f698456b9093b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1561d381b2e1ed0b2f698456b9093b6">Insert</a> (<a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> index, const TYPE &amp;elm)</td></tr>
<tr class="memdesc:af1561d381b2e1ed0b2f698456b9093b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert element before element at index  <br /></td></tr>
<tr class="separator:af1561d381b2e1ed0b2f698456b9093b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684cb643702b3738bc70f05e4929c622" id="r_a684cb643702b3738bc70f05e4929c622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a684cb643702b3738bc70f05e4929c622">InsertSorted</a> (const TYPE &amp;elm)</td></tr>
<tr class="memdesc:a684cb643702b3738bc70f05e4929c622"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert element into sorted array, return index where element was included  <br /></td></tr>
<tr class="separator:a684cb643702b3738bc70f05e4929c622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ae390f39de514fc884ebaa65f58fbd" id="r_aa2ae390f39de514fc884ebaa65f58fbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2ae390f39de514fc884ebaa65f58fbd">InsertAtEndOfIdenticalRange</a> (<a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> startIndex, const TYPE &amp;elm)</td></tr>
<tr class="memdesc:aa2ae390f39de514fc884ebaa65f58fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert element at the first non-identical position, return index of inclusion position  <br /></td></tr>
<tr class="separator:aa2ae390f39de514fc884ebaa65f58fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c842921abd4b43697f1d81bc2f09307" id="r_a0c842921abd4b43697f1d81bc2f09307"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c842921abd4b43697f1d81bc2f09307">IsSorted</a> () const</td></tr>
<tr class="memdesc:a0c842921abd4b43697f1d81bc2f09307"><td class="mdescLeft">&#160;</td><td class="mdescRight">test if the array is sorted, this is a slow operation!  <br /></td></tr>
<tr class="separator:a0c842921abd4b43697f1d81bc2f09307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff9eb1a266e21996015d4527a0723fb" id="r_afff9eb1a266e21996015d4527a0723fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afff9eb1a266e21996015d4527a0723fb">Clear</a> ()</td></tr>
<tr class="memdesc:afff9eb1a266e21996015d4527a0723fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear array (calls destructors)  <br /></td></tr>
<tr class="separator:afff9eb1a266e21996015d4527a0723fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c53324cd28c115495b1eec6b461d57" id="r_af9c53324cd28c115495b1eec6b461d57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9c53324cd28c115495b1eec6b461d57">Reset</a> ()</td></tr>
<tr class="memdesc:af9c53324cd28c115495b1eec6b461d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset array (does NOT call destructors)  <br /></td></tr>
<tr class="separator:af9c53324cd28c115495b1eec6b461d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3afa98f2b93c5702a431d50bee7b49" id="r_a4d3afa98f2b93c5702a431d50bee7b49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d3afa98f2b93c5702a431d50bee7b49">Free</a> ()</td></tr>
<tr class="memdesc:a4d3afa98f2b93c5702a431d50bee7b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">free memory and reset size  <br /></td></tr>
<tr class="separator:a4d3afa98f2b93c5702a431d50bee7b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad737b8a110d91f381edb368675831cd2" id="r_ad737b8a110d91f381edb368675831cd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad737b8a110d91f381edb368675831cd2">Begin</a> () const</td></tr>
<tr class="memdesc:ad737b8a110d91f381edb368675831cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return iterator to beginning of array  <br /></td></tr>
<tr class="separator:ad737b8a110d91f381edb368675831cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84f2afe805cb25d4a3b93b981841b29" id="r_af84f2afe805cb25d4a3b93b981841b29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af84f2afe805cb25d4a3b93b981841b29">End</a> () const</td></tr>
<tr class="memdesc:af84f2afe805cb25d4a3b93b981841b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">return iterator to end of array  <br /></td></tr>
<tr class="separator:af84f2afe805cb25d4a3b93b981841b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a59dd410f6b5fc2954f9645423f559e" id="r_a4a59dd410f6b5fc2954f9645423f559e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a59dd410f6b5fc2954f9645423f559e">Find</a> (const TYPE &amp;elm) const</td></tr>
<tr class="memdesc:a4a59dd410f6b5fc2954f9645423f559e"><td class="mdescLeft">&#160;</td><td class="mdescRight">find identical element in array, return iterator  <br /></td></tr>
<tr class="separator:a4a59dd410f6b5fc2954f9645423f559e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7588f77c3717e6cee6e3718fb9cd332" id="r_af7588f77c3717e6cee6e3718fb9cd332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7588f77c3717e6cee6e3718fb9cd332">FindIndex</a> (const TYPE &amp;elm) const</td></tr>
<tr class="memdesc:af7588f77c3717e6cee6e3718fb9cd332"><td class="mdescLeft">&#160;</td><td class="mdescRight">find identical element in array, return index, InvalidIndex if not found  <br /></td></tr>
<tr class="separator:af7588f77c3717e6cee6e3718fb9cd332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e90b517bffc6292bbfe8322e1899e2" id="r_aa3e90b517bffc6292bbfe8322e1899e2"><td class="memTemplParams" colspan="2">template&lt;typename KEYTYPE &gt; </td></tr>
<tr class="memitem:aa3e90b517bffc6292bbfe8322e1899e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa3e90b517bffc6292bbfe8322e1899e2">FindIndex</a> (typename std::enable_if&lt; true, const KEYTYPE &amp; &gt;::type elm) const</td></tr>
<tr class="memdesc:aa3e90b517bffc6292bbfe8322e1899e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">find identical element using a specific key type  <br /></td></tr>
<tr class="separator:aa3e90b517bffc6292bbfe8322e1899e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3201d7c5b86d20a66feb5e80c499e53a" id="r_a3201d7c5b86d20a66feb5e80c499e53a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3201d7c5b86d20a66feb5e80c499e53a">Fill</a> (<a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> first, <a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> num, const TYPE &amp;elm)</td></tr>
<tr class="memdesc:a3201d7c5b86d20a66feb5e80c499e53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill array range with element  <br /></td></tr>
<tr class="separator:a3201d7c5b86d20a66feb5e80c499e53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c510c4a7e7aa119caeb01eb06db96e6" id="r_a4c510c4a7e7aa119caeb01eb06db96e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c510c4a7e7aa119caeb01eb06db96e6">Realloc</a> (<a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> <a class="el" href="#a26c1a47bc10da4fb55227a0fcb6ccc32">capacity</a>, <a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> <a class="el" href="#a4f3e359e9537f9f7c3b8d12617bdcc9e">grow</a>)</td></tr>
<tr class="memdesc:a4c510c4a7e7aa119caeb01eb06db96e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear contents and preallocate with new attributes  <br /></td></tr>
<tr class="separator:a4c510c4a7e7aa119caeb01eb06db96e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969db006c74a4ff8d0e29a4dfb3f63d7" id="r_a969db006c74a4ff8d0e29a4dfb3f63d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a969db006c74a4ff8d0e29a4dfb3f63d7">Difference</a> (const <a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a969db006c74a4ff8d0e29a4dfb3f63d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns new array with elements which are not in rhs (slow!)  <br /></td></tr>
<tr class="separator:a969db006c74a4ff8d0e29a4dfb3f63d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc28358010ac536500a6ba232a692fa4" id="r_afc28358010ac536500a6ba232a692fa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc28358010ac536500a6ba232a692fa4">Sort</a> ()</td></tr>
<tr class="memdesc:afc28358010ac536500a6ba232a692fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">sort the array  <br /></td></tr>
<tr class="separator:afc28358010ac536500a6ba232a692fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750e055c8878779ed2bb66fb6c92d6a6" id="r_a750e055c8878779ed2bb66fb6c92d6a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a750e055c8878779ed2bb66fb6c92d6a6">SortWithFunc</a> (bool(*func)(const TYPE &amp;lhs, const TYPE &amp;rhs))</td></tr>
<tr class="memdesc:a750e055c8878779ed2bb66fb6c92d6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">sort with custom function  <br /></td></tr>
<tr class="separator:a750e055c8878779ed2bb66fb6c92d6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd0895573831244b1d6e2ffd3b2663b" id="r_a6fd0895573831244b1d6e2ffd3b2663b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fd0895573831244b1d6e2ffd3b2663b">BinarySearchIndex</a> (const TYPE &amp;elm) const</td></tr>
<tr class="memdesc:a6fd0895573831244b1d6e2ffd3b2663b"><td class="mdescLeft">&#160;</td><td class="mdescRight">do a binary search, requires a sorted array  <br /></td></tr>
<tr class="separator:a6fd0895573831244b1d6e2ffd3b2663b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196f39d9ffc6c0fc1b1ee77d1579cf93" id="r_a196f39d9ffc6c0fc1b1ee77d1579cf93"><td class="memTemplParams" colspan="2">template&lt;typename KEYTYPE &gt; </td></tr>
<tr class="memitem:a196f39d9ffc6c0fc1b1ee77d1579cf93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a196f39d9ffc6c0fc1b1ee77d1579cf93">BinarySearchIndex</a> (typename std::enable_if&lt; true, const KEYTYPE &amp; &gt;::type elm) const</td></tr>
<tr class="memdesc:a196f39d9ffc6c0fc1b1ee77d1579cf93"><td class="mdescLeft">&#160;</td><td class="mdescRight">do binary search with explicit typed element  <br /></td></tr>
<tr class="separator:a196f39d9ffc6c0fc1b1ee77d1579cf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacefb73ea935b8abf2f3b1f682955377" id="r_aacefb73ea935b8abf2f3b1f682955377"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacefb73ea935b8abf2f3b1f682955377">IsStackUsed</a> () const</td></tr>
<tr class="memdesc:aacefb73ea935b8abf2f3b1f682955377"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the stack is used  <br /></td></tr>
<tr class="separator:aacefb73ea935b8abf2f3b1f682955377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddebb1fc0e24396cd385e8f6be4f9ab" id="r_a7ddebb1fc0e24396cd385e8f6be4f9ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ddebb1fc0e24396cd385e8f6be4f9ab">begin</a> () const</td></tr>
<tr class="memdesc:a7ddebb1fc0e24396cd385e8f6be4f9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">for range-based iteration  <br /></td></tr>
<tr class="separator:a7ddebb1fc0e24396cd385e8f6be4f9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accaf946fd4274749bd5524a440be4c79" id="r_accaf946fd4274749bd5524a440be4c79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accaf946fd4274749bd5524a440be4c79">end</a> () const</td></tr>
<tr class="separator:accaf946fd4274749bd5524a440be4c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a215bc8bcf2c09b642af1f1da879bb541" id="r_a215bc8bcf2c09b642af1f1da879bb541"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a215bc8bcf2c09b642af1f1da879bb541">Destroy</a> (TYPE *elm)</td></tr>
<tr class="memdesc:a215bc8bcf2c09b642af1f1da879bb541"><td class="mdescLeft">&#160;</td><td class="mdescRight">destroy an element (call destructor without freeing memory)  <br /></td></tr>
<tr class="separator:a215bc8bcf2c09b642af1f1da879bb541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eca25cdd91b0b3cc05d417690ee20ab" id="r_a6eca25cdd91b0b3cc05d417690ee20ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eca25cdd91b0b3cc05d417690ee20ab">Copy</a> (const <a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;src)</td></tr>
<tr class="memdesc:a6eca25cdd91b0b3cc05d417690ee20ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy content  <br /></td></tr>
<tr class="separator:a6eca25cdd91b0b3cc05d417690ee20ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1894b8cd6c3c6877a1df3c45283c1b" id="r_abf1894b8cd6c3c6877a1df3c45283c1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf1894b8cd6c3c6877a1df3c45283c1b">Delete</a> ()</td></tr>
<tr class="memdesc:abf1894b8cd6c3c6877a1df3c45283c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete content  <br /></td></tr>
<tr class="separator:abf1894b8cd6c3c6877a1df3c45283c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1aeccad29a8cdaa18e38e64a20d48b" id="r_abc1aeccad29a8cdaa18e38e64a20d48b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc1aeccad29a8cdaa18e38e64a20d48b">Grow</a> ()</td></tr>
<tr class="memdesc:abc1aeccad29a8cdaa18e38e64a20d48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">grow array  <br /></td></tr>
<tr class="separator:abc1aeccad29a8cdaa18e38e64a20d48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d1e14b024ca8673f27becf679c07de" id="r_a52d1e14b024ca8673f27becf679c07de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52d1e14b024ca8673f27becf679c07de">GrowTo</a> (<a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> newCapacity)</td></tr>
<tr class="memdesc:a52d1e14b024ca8673f27becf679c07de"><td class="mdescLeft">&#160;</td><td class="mdescRight">grow array to target size  <br /></td></tr>
<tr class="separator:a52d1e14b024ca8673f27becf679c07de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78ceb8f12353aeb27b473e389034d3e" id="r_ad78ceb8f12353aeb27b473e389034d3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78ceb8f12353aeb27b473e389034d3e">Move</a> (<a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> fromIndex, <a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> toIndex)</td></tr>
<tr class="memdesc:ad78ceb8f12353aeb27b473e389034d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">move elements, grows array if needed  <br /></td></tr>
<tr class="separator:ad78ceb8f12353aeb27b473e389034d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4f3e359e9537f9f7c3b8d12617bdcc9e" id="r_a4f3e359e9537f9f7c3b8d12617bdcc9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f3e359e9537f9f7c3b8d12617bdcc9e">grow</a></td></tr>
<tr class="separator:a4f3e359e9537f9f7c3b8d12617bdcc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c1a47bc10da4fb55227a0fcb6ccc32" id="r_a26c1a47bc10da4fb55227a0fcb6ccc32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26c1a47bc10da4fb55227a0fcb6ccc32">capacity</a></td></tr>
<tr class="separator:a26c1a47bc10da4fb55227a0fcb6ccc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff154ddd458ac3bfcea6780aba95181" id="r_a7ff154ddd458ac3bfcea6780aba95181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ff154ddd458ac3bfcea6780aba95181">count</a></td></tr>
<tr class="separator:a7ff154ddd458ac3bfcea6780aba95181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4c4a177c480ddb47df0067f1ef5988" id="r_aec4c4a177c480ddb47df0067f1ef5988"><td class="memItemLeft" align="right" valign="top">TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec4c4a177c480ddb47df0067f1ef5988">smallVector</a> [STACK_SIZE]</td></tr>
<tr class="separator:aec4c4a177c480ddb47df0067f1ef5988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e4a68324a4a081cc8a4160a5479e46" id="r_a95e4a68324a4a081cc8a4160a5479e46"><td class="memItemLeft" align="right" valign="top">TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95e4a68324a4a081cc8a4160a5479e46">elements</a></td></tr>
<tr class="separator:a95e4a68324a4a081cc8a4160a5479e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a0c9fbbc78235383dc96b7ec5926bedc8" id="r_a0c9fbbc78235383dc96b7ec5926bedc8"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c9fbbc78235383dc96b7ec5926bedc8">MinGrowSize</a> = 16</td></tr>
<tr class="separator:a0c9fbbc78235383dc96b7ec5926bedc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3ec5e70dd0c1785af747658484daac" id="r_a5b3ec5e70dd0c1785af747658484daac"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b3ec5e70dd0c1785af747658484daac">MaxGrowSize</a> = 65536</td></tr>
<tr class="separator:a5b3ec5e70dd0c1785af747658484daac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aed444fe3290d1b9c0c16f145502201e9" name="aed444fe3290d1b9c0c16f145502201e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed444fe3290d1b9c0c16f145502201e9">&#9670;&#160;</a></span>Iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TYPE* <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>define iterator </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a69799b7ac144dbfd06fa28c11fe89350" name="a69799b7ac144dbfd06fa28c11fe89350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69799b7ac144dbfd06fa28c11fe89350">&#9670;&#160;</a></span>ArrayStack() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::ArrayStack </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor with default parameters </p>

</div>
</div>
<a id="aa2d94b271c968f8b74461951a4ece728" name="aa2d94b271c968f8b74461951a4ece728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d94b271c968f8b74461951a4ece728">&#9670;&#160;</a></span>ArrayStack() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::ArrayStack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a></td>          <td class="paramname"><span class="paramname"><em>initialCapacity</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a></td>          <td class="paramname"><span class="paramname"><em>initialGrow</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constuctor with initial size and grow size </p>

</div>
</div>
<a id="a2f6c93119621e1be3fef5c5a7f70a03b" name="a2f6c93119621e1be3fef5c5a7f70a03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6c93119621e1be3fef5c5a7f70a03b">&#9670;&#160;</a></span>ArrayStack() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::ArrayStack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a></td>          <td class="paramname"><span class="paramname"><em>initialSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a></td>          <td class="paramname"><span class="paramname"><em>initialGrow</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;</td>          <td class="paramname"><span class="paramname"><em>initialValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor with initial size, grow size and initial values </p>

</div>
</div>
<a id="a6799725898c8c2652b281b2d604388ef" name="a6799725898c8c2652b281b2d604388ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6799725898c8c2652b281b2d604388ef">&#9670;&#160;</a></span>ArrayStack() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::ArrayStack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy constructor </p>

</div>
</div>
<a id="a9006a300fd3a18624a3ad653ac9659cb" name="a9006a300fd3a18624a3ad653ac9659cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9006a300fd3a18624a3ad653ac9659cb">&#9670;&#160;</a></span>ArrayStack() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::ArrayStack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move constructor </p>

</div>
</div>
<a id="a43058b28e64cf8084cd69c33a63745cb" name="a43058b28e64cf8084cd69c33a63745cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43058b28e64cf8084cd69c33a63745cb">&#9670;&#160;</a></span>ArrayStack() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::ArrayStack </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; TYPE &gt;</td>          <td class="paramname"><span class="paramname"><em>list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor from initializer list </p>

</div>
</div>
<a id="ae5a430d0ee2f77e396ae2085a554f1de" name="ae5a430d0ee2f77e396ae2085a554f1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a430d0ee2f77e396ae2085a554f1de">&#9670;&#160;</a></span>~ArrayStack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::~<a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abfd2920e7c447e623105a05df9c4855d" name="abfd2920e7c447e623105a05df9c4855d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd2920e7c447e623105a05df9c4855d">&#9670;&#160;</a></span>Append() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Append </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;</td>          <td class="paramname"><span class="paramname"><em>elm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>append element to end of array </p>

</div>
</div>
<a id="a633a1fcb9d8ec727e618e7bdd5d755da" name="a633a1fcb9d8ec727e618e7bdd5d755da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633a1fcb9d8ec727e618e7bdd5d755da">&#9670;&#160;</a></span>Append() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<div class="memtemplate">
template&lt;typename ... ELEM_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Append </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;</td>          <td class="paramname"><span class="paramname"><em>first</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ELEM_TYPE &amp;...</td>          <td class="paramname"><span class="paramname"><em>elements</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append multiple elements to the end of the array. </p>

</div>
</div>
<a id="a3eccc1033ab1257c7f037e6db2ab19b5" name="a3eccc1033ab1257c7f037e6db2ab19b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eccc1033ab1257c7f037e6db2ab19b5">&#9670;&#160;</a></span>Append() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Append </td>
          <td>(</td>
          <td class="paramtype">TYPE &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>elm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>append an element which is being forwarded </p>

</div>
</div>
<a id="a763499ceb1daa406a2e04dab17a720fb" name="a763499ceb1daa406a2e04dab17a720fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763499ceb1daa406a2e04dab17a720fb">&#9670;&#160;</a></span>AppendArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::AppendArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>append the contents of an array to this array </p>

</div>
</div>
<a id="a87b3304327830a0ffb815b0e521f60eb" name="a87b3304327830a0ffb815b0e521f60eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b3304327830a0ffb815b0e521f60eb">&#9670;&#160;</a></span>AppendArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::AppendArray </td>
          <td>(</td>
          <td class="paramtype">const TYPE *</td>          <td class="paramname"><span class="paramname"><em>arr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>append from C array </p>

</div>
</div>
<a id="abda541e3abf746bad70bc55ac8f44227" name="abda541e3abf746bad70bc55ac8f44227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda541e3abf746bad70bc55ac8f44227">&#9670;&#160;</a></span>As()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::As </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert to "anything" </p>

</div>
</div>
<a id="ae0d4e460efc6c0d11c314e2a9556f5ef" name="ae0d4e460efc6c0d11c314e2a9556f5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d4e460efc6c0d11c314e2a9556f5ef">&#9670;&#160;</a></span>Back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE &amp; <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return reference to last element </p>

</div>
</div>
<a id="ad737b8a110d91f381edb368675831cd2" name="ad737b8a110d91f381edb368675831cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad737b8a110d91f381edb368675831cd2">&#9670;&#160;</a></span>Begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;<a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">::Iterator</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return iterator to beginning of array </p>

</div>
</div>
<a id="a7ddebb1fc0e24396cd385e8f6be4f9ab" name="a7ddebb1fc0e24396cd385e8f6be4f9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ddebb1fc0e24396cd385e8f6be4f9ab">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;<a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">::Iterator</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>for range-based iteration </p>

</div>
</div>
<a id="a6fd0895573831244b1d6e2ffd3b2663b" name="a6fd0895573831244b1d6e2ffd3b2663b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd0895573831244b1d6e2ffd3b2663b">&#9670;&#160;</a></span>BinarySearchIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::BinarySearchIndex </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;</td>          <td class="paramname"><span class="paramname"><em>elm</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>do a binary search, requires a sorted array </p>
<p>Does a binary search on the array, returns the index of the identical element, or InvalidIndex if not found. </p>

</div>
</div>
<a id="a196f39d9ffc6c0fc1b1ee77d1579cf93" name="a196f39d9ffc6c0fc1b1ee77d1579cf93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196f39d9ffc6c0fc1b1ee77d1579cf93">&#9670;&#160;</a></span>BinarySearchIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<div class="memtemplate">
template&lt;typename KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::BinarySearchIndex </td>
          <td>(</td>
          <td class="paramtype">typename std::enable_if&lt; true, const KEYTYPE &amp; &gt;::type</td>          <td class="paramname"><span class="paramname"><em>elm</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>do binary search with explicit typed element </p>
<p>Template type is used to force a specific type comparison.</p>
<p>This might mitigate some expensive implicit constructions to TYPE.</p>
<p>This templated method requires a explicit template type, which is enforced by using typename to put the template type in a non-deducable context. The enable_if does nothing except allow us to use typename. </p>

</div>
</div>
<a id="ab5805c0b9f0cf732225332b5b9561ec9" name="ab5805c0b9f0cf732225332b5b9561ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5805c0b9f0cf732225332b5b9561ec9">&#9670;&#160;</a></span>ByteSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::ByteSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the byte size of the array. </p>

</div>
</div>
<a id="ab3f66cf42e93016761c7f8f0521c1833" name="ab3f66cf42e93016761c7f8f0521c1833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f66cf42e93016761c7f8f0521c1833">&#9670;&#160;</a></span>Capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get overall allocated size of array in number of elements </p>

</div>
</div>
<a id="afff9eb1a266e21996015d4527a0723fb" name="afff9eb1a266e21996015d4527a0723fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff9eb1a266e21996015d4527a0723fb">&#9670;&#160;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clear array (calls destructors) </p>
<p>The current implementation of this method does not shrink the preallocated space.</p>
<p>It simply sets the array size to 0. </p>

</div>
</div>
<a id="a6eca25cdd91b0b3cc05d417690ee20ab" name="a6eca25cdd91b0b3cc05d417690ee20ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eca25cdd91b0b3cc05d417690ee20ab">&#9670;&#160;</a></span>Copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy content </p>

</div>
</div>
<a id="abf1894b8cd6c3c6877a1df3c45283c1b" name="abf1894b8cd6c3c6877a1df3c45283c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1894b8cd6c3c6877a1df3c45283c1b">&#9670;&#160;</a></span>Delete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Delete </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>delete content </p>

</div>
</div>
<a id="a215bc8bcf2c09b642af1f1da879bb541" name="a215bc8bcf2c09b642af1f1da879bb541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215bc8bcf2c09b642af1f1da879bb541">&#9670;&#160;</a></span>Destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Destroy </td>
          <td>(</td>
          <td class="paramtype">TYPE *</td>          <td class="paramname"><span class="paramname"><em>elm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destroy an element (call destructor without freeing memory) </p>

</div>
</div>
<a id="a969db006c74a4ff8d0e29a4dfb3f63d7" name="a969db006c74a4ff8d0e29a4dfb3f63d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a969db006c74a4ff8d0e29a4dfb3f63d7">&#9670;&#160;</a></span>Difference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns new array with elements which are not in rhs (slow!) </p>
<p>Returns a new array with all element which are in rhs, but not in this.</p>
<p>Carefull, this method may be very slow with large arrays!</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000028">Todo</a></b></dt><dd>this method is broken, check test case to see why! </dd></dl>

</div>
</div>
<a id="af84f2afe805cb25d4a3b93b981841b29" name="af84f2afe805cb25d4a3b93b981841b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84f2afe805cb25d4a3b93b981841b29">&#9670;&#160;</a></span>End()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;<a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">::Iterator</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::End </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return iterator to end of array </p>

</div>
</div>
<a id="accaf946fd4274749bd5524a440be4c79" name="accaf946fd4274749bd5524a440be4c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accaf946fd4274749bd5524a440be4c79">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;<a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">::Iterator</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd9be93fa632dbad512edc4f593b4af5" name="afd9be93fa632dbad512edc4f593b4af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9be93fa632dbad512edc4f593b4af5">&#9670;&#160;</a></span>Erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;<a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">::Iterator</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>erase element pointed to by iterator, keep sorting intact </p>

</div>
</div>
<a id="aa9f150a7355d99fe4b2ba9bfc2fee185" name="aa9f150a7355d99fe4b2ba9bfc2fee185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f150a7355d99fe4b2ba9bfc2fee185">&#9670;&#160;</a></span>EraseBack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::EraseBack </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>erase last element </p>

</div>
</div>
<a id="a4f0eb3c5bd69dbd866349f508a200cd7" name="a4f0eb3c5bd69dbd866349f508a200cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f0eb3c5bd69dbd866349f508a200cd7">&#9670;&#160;</a></span>EraseFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::EraseFront </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>erase first element </p>

</div>
</div>
<a id="a7ef691cba5741b53bf292aeb632d6d42" name="a7ef691cba5741b53bf292aeb632d6d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef691cba5741b53bf292aeb632d6d42">&#9670;&#160;</a></span>EraseIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::EraseIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>erase element at index, keep sorting intact </p>

</div>
</div>
<a id="adad95c749874686f63627225bc7138b6" name="adad95c749874686f63627225bc7138b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad95c749874686f63627225bc7138b6">&#9670;&#160;</a></span>EraseIndexSwap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::EraseIndexSwap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>erase element at index, fill gap by swapping in last element, destroys sorting! </p>
<p>NOTE: this method is fast but destroys the sorting order! </p>

</div>
</div>
<a id="a68535f93e92d5a5f874b02948cc9ff83" name="a68535f93e92d5a5f874b02948cc9ff83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68535f93e92d5a5f874b02948cc9ff83">&#9670;&#160;</a></span>EraseSwap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;<a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">::Iterator</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::EraseSwap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">Iterator</a></td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>erase element at iterator, fill gap by swapping in last element, destroys sorting! </p>
<p>NOTE: this method is fast but destroys the sorting order! </p>

</div>
</div>
<a id="a3201d7c5b86d20a66feb5e80c499e53a" name="a3201d7c5b86d20a66feb5e80c499e53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3201d7c5b86d20a66feb5e80c499e53a">&#9670;&#160;</a></span>Fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a></td>          <td class="paramname"><span class="paramname"><em>first</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a></td>          <td class="paramname"><span class="paramname"><em>num</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;</td>          <td class="paramname"><span class="paramname"><em>elm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fill array range with element </p>
<p>Fills an array range with the given element value.</p>
<p>Will grow the array if necessary</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>index of first element to start fill </td></tr>
    <tr><td class="paramname">num</td><td>num elements to fill </td></tr>
    <tr><td class="paramname">elm</td><td>fill value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a59dd410f6b5fc2954f9645423f559e" name="a4a59dd410f6b5fc2954f9645423f559e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a59dd410f6b5fc2954f9645423f559e">&#9670;&#160;</a></span>Find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;<a class="el" href="#aed444fe3290d1b9c0c16f145502201e9">::Iterator</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Find </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;</td>          <td class="paramname"><span class="paramname"><em>elm</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find identical element in array, return iterator </p>
<p>Find element in array, return iterator, or 0 if element not found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elm</td><td>element to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>element iterator, or 0 if not found </dd></dl>

</div>
</div>
<a id="af7588f77c3717e6cee6e3718fb9cd332" name="af7588f77c3717e6cee6e3718fb9cd332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7588f77c3717e6cee6e3718fb9cd332">&#9670;&#160;</a></span>FindIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::FindIndex </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;</td>          <td class="paramname"><span class="paramname"><em>elm</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find identical element in array, return index, InvalidIndex if not found </p>
<p>Find element in array, return element index, or InvalidIndex if element not found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elm</td><td>element to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index to element, or InvalidIndex if not found </dd></dl>

</div>
</div>
<a id="aa3e90b517bffc6292bbfe8322e1899e2" name="aa3e90b517bffc6292bbfe8322e1899e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e90b517bffc6292bbfe8322e1899e2">&#9670;&#160;</a></span>FindIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<div class="memtemplate">
template&lt;typename KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::FindIndex </td>
          <td>(</td>
          <td class="paramtype">typename std::enable_if&lt; true, const KEYTYPE &amp; &gt;::type</td>          <td class="paramname"><span class="paramname"><em>elm</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find identical element using a specific key type </p>
<p>Find element in array, return element index, or InvalidIndex if element not found.</p>
<p>Template type is used to force a specific type comparison. This might mitigate some expensive implicit constructions to TYPE.</p>
<p>This templated method requires a explicit template type, which is enforced by using typename to put the template type in a non-deducable context. The enable_if does nothing except allow us to use typename.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elm</td><td>element to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index to element, or InvalidIndex if not found </dd></dl>

</div>
</div>
<a id="a4d3afa98f2b93c5702a431d50bee7b49" name="a4d3afa98f2b93c5702a431d50bee7b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3afa98f2b93c5702a431d50bee7b49">&#9670;&#160;</a></span>Free()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Free </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>free memory and reset size </p>
<p>Free up memory and reset the grow. </p>

</div>
</div>
<a id="ab10437288095b2efb90bb554d342fb86" name="ab10437288095b2efb90bb554d342fb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10437288095b2efb90bb554d342fb86">&#9670;&#160;</a></span>Front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE &amp; <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return reference to first element </p>

</div>
</div>
<a id="abc1aeccad29a8cdaa18e38e64a20d48b" name="abc1aeccad29a8cdaa18e38e64a20d48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1aeccad29a8cdaa18e38e64a20d48b">&#9670;&#160;</a></span>Grow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Grow </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>grow array </p>

</div>
</div>
<a id="a52d1e14b024ca8673f27becf679c07de" name="a52d1e14b024ca8673f27becf679c07de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d1e14b024ca8673f27becf679c07de">&#9670;&#160;</a></span>GrowTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::GrowTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a></td>          <td class="paramname"><span class="paramname"><em>newCapacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>grow array to target size </p>

</div>
</div>
<a id="af1561d381b2e1ed0b2f698456b9093b6" name="af1561d381b2e1ed0b2f698456b9093b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1561d381b2e1ed0b2f698456b9093b6">&#9670;&#160;</a></span>Insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a></td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;</td>          <td class="paramname"><span class="paramname"><em>elm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>insert element before element at index </p>

</div>
</div>
<a id="aa2ae390f39de514fc884ebaa65f58fbd" name="aa2ae390f39de514fc884ebaa65f58fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ae390f39de514fc884ebaa65f58fbd">&#9670;&#160;</a></span>InsertAtEndOfIdenticalRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::InsertAtEndOfIdenticalRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a></td>          <td class="paramname"><span class="paramname"><em>startIndex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;</td>          <td class="paramname"><span class="paramname"><em>elm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>insert element at the first non-identical position, return index of inclusion position </p>
<p>This inserts an element at the end of a range of identical elements starting at a given index.</p>
<p>Performance is O(n). Returns the index at which the element was added. </p>

</div>
</div>
<a id="a684cb643702b3738bc70f05e4929c622" name="a684cb643702b3738bc70f05e4929c622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684cb643702b3738bc70f05e4929c622">&#9670;&#160;</a></span>InsertSorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::InsertSorted </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;</td>          <td class="paramname"><span class="paramname"><em>elm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>insert element into sorted array, return index where element was included </p>
<p>This inserts the element into a sorted array.</p>
<p>Returns the index at which the element was inserted. </p>

</div>
</div>
<a id="a8e94be31aa8a403ca746f53d875cedfa" name="a8e94be31aa8a403ca746f53d875cedfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e94be31aa8a403ca746f53d875cedfa">&#9670;&#160;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::IsEmpty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return true if array empty </p>

</div>
</div>
<a id="a0c842921abd4b43697f1d81bc2f09307" name="a0c842921abd4b43697f1d81bc2f09307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c842921abd4b43697f1d81bc2f09307">&#9670;&#160;</a></span>IsSorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::IsSorted </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>test if the array is sorted, this is a slow operation! </p>
<p>This tests, whether the array is sorted.</p>
<p>This is a slow operation O(n). </p>

</div>
</div>
<a id="aacefb73ea935b8abf2f3b1f682955377" name="aacefb73ea935b8abf2f3b1f682955377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacefb73ea935b8abf2f3b1f682955377">&#9670;&#160;</a></span>IsStackUsed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::IsStackUsed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the stack is used </p>

</div>
</div>
<a id="ad78ceb8f12353aeb27b473e389034d3e" name="ad78ceb8f12353aeb27b473e389034d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78ceb8f12353aeb27b473e389034d3e">&#9670;&#160;</a></span>Move()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a></td>          <td class="paramname"><span class="paramname"><em>fromIndex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a></td>          <td class="paramname"><span class="paramname"><em>toIndex</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move elements, grows array if needed </p>
<p>30-Jan-03 floh serious bugfixes! 07-Dec-04 jo bugfix: neededSize &gt;= this-&gt;capacity =&gt; neededSize &gt; capacity <br  />
 </p>

</div>
</div>
<a id="a8b517266cba92cdc4fccb79e5c898d43" name="a8b517266cba92cdc4fccb79e5c898d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b517266cba92cdc4fccb79e5c898d43">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inequality operator </p>
<p>The inequality operator returns true if at least one element in the array is different, or the array sizes are different. </p>

</div>
</div>
<a id="a0ba9b50a81a5476179a120b1a1773291" name="a0ba9b50a81a5476179a120b1a1773291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba9b50a81a5476179a120b1a1773291">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move operator </p>

</div>
</div>
<a id="a56eb882dce5807bab737d3f39dc1897e" name="a56eb882dce5807bab737d3f39dc1897e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56eb882dce5807bab737d3f39dc1897e">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assignment operator </p>

</div>
</div>
<a id="ad0ac621d1fc25574bc2e24ef9c39dc6e" name="ad0ac621d1fc25574bc2e24ef9c39dc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ac621d1fc25574bc2e24ef9c39dc6e">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a>&lt; TYPE, STACK_SIZE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>equality operator </p>
<p>The equality operator returns true if all elements are identical.</p>
<p>The TYPE class must support the equality operator. </p>

</div>
</div>
<a id="a32fc39fa91ad39db9f5333d2699950c4" name="a32fc39fa91ad39db9f5333d2699950c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fc39fa91ad39db9f5333d2699950c4">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE &amp; <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#ad119735112d40fd29a3017de944ccc98">IndexT</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[] operator </p>
<p>Access an element.</p>
<p>This method will NOT grow the array, and instead do a range check, which may throw an assertion. </p>

</div>
</div>
<a id="a4c510c4a7e7aa119caeb01eb06db96e6" name="a4c510c4a7e7aa119caeb01eb06db96e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c510c4a7e7aa119caeb01eb06db96e6">&#9670;&#160;</a></span>Realloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Realloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a></td>          <td class="paramname"><span class="paramname"><em>capacity</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a></td>          <td class="paramname"><span class="paramname"><em>grow</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clear contents and preallocate with new attributes </p>

</div>
</div>
<a id="a9c736efed4e19139cf9dca169305727d" name="a9c736efed4e19139cf9dca169305727d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c736efed4e19139cf9dca169305727d">&#9670;&#160;</a></span>Reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a></td>          <td class="paramname"><span class="paramname"><em>num</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>increase capacity to fit N more elements into the array </p>
<p>This increases the capacity to make room for N elements.</p>
<p>If the number of elements is known before appending the elements, this method can be used to prevent reallocation. If there is already enough room for N more elements, nothing will happen.</p>
<p>NOTE: the functionality of this method has been changed as of 26-Apr-08, it will now only change the capacity of the array, not its size. </p>

</div>
</div>
<a id="af9c53324cd28c115495b1eec6b461d57" name="af9c53324cd28c115495b1eec6b461d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c53324cd28c115495b1eec6b461d57">&#9670;&#160;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Reset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reset array (does NOT call destructors) </p>
<p>This is identical with <a class="el" href="#afff9eb1a266e21996015d4527a0723fb" title="clear array (calls destructors)">Clear()</a>, but does NOT call destructors (it just resets the size member.</p>
<p>USE WITH CARE! </p>

</div>
</div>
<a id="ae74cee49eca92ea93f4d3f8ffbf791ac" name="ae74cee49eca92ea93f4d3f8ffbf791ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74cee49eca92ea93f4d3f8ffbf791ac">&#9670;&#160;</a></span>Size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get number of elements in array </p>

</div>
</div>
<a id="afc28358010ac536500a6ba232a692fa4" name="afc28358010ac536500a6ba232a692fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc28358010ac536500a6ba232a692fa4">&#9670;&#160;</a></span>Sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::Sort </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sort the array </p>
<p>Sorts the array.</p>
<p>This just calls the STL sort algorithm. </p>

</div>
</div>
<a id="a750e055c8878779ed2bb66fb6c92d6a6" name="a750e055c8878779ed2bb66fb6c92d6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750e055c8878779ed2bb66fb6c92d6a6">&#9670;&#160;</a></span>SortWithFunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::SortWithFunc </td>
          <td>(</td>
          <td class="paramtype">bool(*)(const TYPE &amp;lhs, const TYPE &amp;rhs)</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sort with custom function </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a26c1a47bc10da4fb55227a0fcb6ccc32" name="a26c1a47bc10da4fb55227a0fcb6ccc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c1a47bc10da4fb55227a0fcb6ccc32">&#9670;&#160;</a></span>capacity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ff154ddd458ac3bfcea6780aba95181" name="a7ff154ddd458ac3bfcea6780aba95181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff154ddd458ac3bfcea6780aba95181">&#9670;&#160;</a></span>count</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a95e4a68324a4a081cc8a4160a5479e46" name="a95e4a68324a4a081cc8a4160a5479e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e4a68324a4a081cc8a4160a5479e46">&#9670;&#160;</a></span>elements</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TYPE* <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::elements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f3e359e9537f9f7c3b8d12617bdcc9e" name="a4f3e359e9537f9f7c3b8d12617bdcc9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3e359e9537f9f7c3b8d12617bdcc9e">&#9670;&#160;</a></span>grow</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::grow</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b3ec5e70dd0c1785af747658484daac" name="a5b3ec5e70dd0c1785af747658484daac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3ec5e70dd0c1785af747658484daac">&#9670;&#160;</a></span>MaxGrowSize</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::MaxGrowSize = 65536</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c9fbbc78235383dc96b7ec5926bedc8" name="a0c9fbbc78235383dc96b7ec5926bedc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9fbbc78235383dc96b7ec5926bedc8">&#9670;&#160;</a></span>MinGrowSize</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="types_8h.html#a869418dc7a0404b6441ebc39c5b4bb37">SizeT</a> <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::MinGrowSize = 16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec4c4a177c480ddb47df0067f1ef5988" name="aec4c4a177c480ddb47df0067f1ef5988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4c4a177c480ddb47df0067f1ef5988">&#9670;&#160;</a></span>smallVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , int STACK_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TYPE <a class="el" href="class_util_1_1_array_stack.html">Util::ArrayStack</a>&lt; TYPE, STACK_SIZE &gt;::smallVector[STACK_SIZE]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/code/foundation/util/<a class="el" href="arraystack_8h_source.html">arraystack.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
		<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
			<ul>
				<li class="navelem"><a class="el" href="namespace_util.html">Util</a></li><li class="navelem"><a class="el" href="class_util_1_1_array_stack.html">ArrayStack</a></li>
				<li class="footer">
					Generated on Thu Mar 14 2024 20:28:24 for Nebula. Dark theme by <a href="http://majerle.eu" target="_new">Tilen Majerle</a>. All rights reserved.
				</li>
			</ul>
		</div>
		<script src="custom.js"></script>
	</body>
</html>
